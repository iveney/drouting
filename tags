!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
BIN	makefile	/^BIN=main$/;"	m
BYTE	header.h	/^typedef unsigned char BYTE ;$/;"	t
Block	header.h	/^class Block{\/\/ a block denote by two points$/;"	c
CC	makefile	/^CC=\/usr\/bin\/g++$/;"	m
Chip	header.h	/^class Chip{\/\/ a chip has an array, timing constraint and subproblems$/;"	c
DBG	makefile	/^DBG=debug$/;"	m
DIRECTION	route.cpp	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	g	file:
DOWN	route.cpp	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	e	enum:DIRECTION	file:
Grid	header.h	/^typedef BYTE Grid ;$/;"	t
GridPoint	header.h	/^	GridPoint(){weight=0;pt=Point(0,0);}$/;"	f	class:GridPoint
GridPoint	header.h	/^	GridPoint(int w,Point p):weight(w),pt(p){}$/;"	f	class:GridPoint
GridPoint	header.h	/^class GridPoint{$/;"	c
INF	header.h	/^const Grid INF=2<<7-1;$/;"	v
LEFT	route.cpp	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	e	enum:DIRECTION	file:
M	header.h	/^	int N,M,T;	\/\/ array size,timing constraint$/;"	m	class:Chip
M	route.cpp	/^int N,M;				\/\/ row\/column count$/;"	v
MAXBLK	header.h	/^const int MAXBLK=10;$/;"	v
MAXBUF	header.h	/^const int MAXBUF=256;$/;"	v
MAXGRID	header.h	/^const int MAXGRID=30;$/;"	v
MAXNET	header.h	/^const int MAXNET=10;$/;"	v
MAXSTR	header.h	/^const int MAXSTR=30;$/;"	v
MAXSUB	header.h	/^const int MAXSUB=100;$/;"	v
MAXTIME	header.h	/^const int MAXTIME=20;$/;"	v
N	header.h	/^	int N,M,T;	\/\/ array size,timing constraint$/;"	m	class:Chip
N	route.cpp	/^int N,M;				\/\/ row\/column count$/;"	v
Net	header.h	/^class Net{\/\/ a net has a name and at most 3 pins$/;"	c
OBJ	makefile	/^OBJ=parser.o route.o header.o$/;"	m
OPT	makefile	/^OPT=-Wall -g$/;"	m
Pin	header.h	/^class Pin{\/\/ a pin has a name and a location$/;"	c
Point	header.h	/^	Point(){x=y=0;}$/;"	f	class:Point
Point	header.h	/^	Point(int xx,int yy):x(xx),y(yy){}$/;"	f	class:Point
Point	header.h	/^class Point{\/\/ a point denote by (row,col)$/;"	c
PtRelativePos	route.cpp	/^DIRECTION PtRelativePos(const Point & l ,const Point & r){$/;"	f
RIGHT	route.cpp	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	e	enum:DIRECTION	file:
SRC	makefile	/^SRC=parser.cpp route.cpp header.c$/;"	m
STAY	route.cpp	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	e	enum:DIRECTION	file:
Subproblem	header.h	/^class Subproblem{\/\/ a subproblem has some blocks and nets$/;"	c
T	header.h	/^	int N,M,T;	\/\/ array size,timing constraint$/;"	m	class:Chip
UP	route.cpp	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	e	enum:DIRECTION	file:
__HEADER_H__	header.h	2;"	d
__PARSER_H__	parser.h	2;"	d
block	header.h	/^	Block block[MAXBLK];$/;"	m	class:Subproblem
blockage	route.cpp	/^BYTE blockage[MAXGRID][MAXGRID];	\/\/ Blockage bitmap$/;"	v
chip	route.cpp	/^Chip chip;				\/\/ Chip data and subproblem$/;"	v
drawSubproblem	parser.cpp	/^void drawSubproblem(Subproblem * prob, int N,int M,int num,char * name){$/;"	f
dx	route.cpp	/^static int dx[]={-1,1,0,0,0};$/;"	v	file:
dy	route.cpp	/^static int dy[]={0,0,1,-1,0};$/;"	v	file:
electrodeCheck	route.cpp	/^bool electrodeCheck(const Point & pt){$/;"	f
fluidicCheck	route.cpp	/^bool fluidicCheck(int which, const Point & pt,int t){$/;"	f
getColor	parser.cpp	/^const char * getColor(){$/;"	f
getColor	util/droute_draw.cpp	/^const char * getColor(){$/;"	f
getNbr	route.cpp	/^vector<Point> getNbr(const Point & pt){$/;"	f
grid	route.cpp	/^Grid grid[MAXNET][MAXGRID][MAXGRID];	\/\/ record the routes, grid[i][x][y]: the time step that net i occupies (x,y)$/;"	v
idx	route.cpp	/^int idx = 1;				\/\/ problem to solve$/;"	v
inGrid	route.cpp	/^bool inGrid(const Point & pt){$/;"	f
init	route.cpp	/^Chip * init(int argc, char * argv[], Chip * chip){$/;"	f
initBlock	route.cpp	/^void initBlock(Subproblem *p){$/;"	f
main	route.cpp	/^int main(int argc, char * argv[]){$/;"	f
main	util/droute_draw.cpp	/^int main(){$/;"	f
nBlock	header.h	/^	int nBlock;$/;"	m	class:Subproblem
nNet	header.h	/^	int nNet;$/;"	m	class:Subproblem
nSubProblem	header.h	/^	int nSubProblem;$/;"	m	class:Chip
name	header.h	/^	char name[MAXSTR];$/;"	m	class:Block
name	header.h	/^	char name[MAXSTR];$/;"	m	class:Net
name	header.h	/^	char name[MAXSTR];$/;"	m	class:Pin
net	header.h	/^	Net net[MAXNET];$/;"	m	class:Subproblem
netcount	route.cpp	/^int netcount;				\/\/ current subproblem's net count$/;"	v
netorder	route.cpp	/^int netorder[MAXNET];			\/\/ net routing order$/;"	v
numPin	header.h	/^	int numPin;$/;"	m	class:Net
operator	header.c	/^ostream & operator <<(ostream & out,Point & pt){$/;"	f
operator !=	header.h	/^	bool operator != (const Point & pt) const {return !operator==(pt);}$/;"	f	class:Point
operator <	header.h	/^	bool operator < (const GridPoint& g){ return weight >= g.weight; }$/;"	f	class:GridPoint
operator ==	header.h	/^	bool operator == (const Point & pt) const {return x==pt.x && y==pt.y;}$/;"	f	class:Point
parse	parser.cpp	/^Chip * parse(FILE * f,Chip * chip){$/;"	f
path	route.cpp	/^Point path[MAXNET][MAXTIME];		\/\/ the routing path : path[i][t]: net i's position at time t$/;"	v
pin	header.h	/^	Pin pin[3];$/;"	m	class:Net
prob	header.h	/^	Subproblem prob[MAXSUB];\/\/ note:prob starts from index 1$/;"	m	class:Chip
pt	header.h	/^	Point pt;$/;"	m	class:GridPoint
pt	header.h	/^	Point pt;$/;"	m	class:Pin
pt	header.h	/^	Point pt[2];$/;"	m	class:Block
sortNet	route.cpp	/^void sortNet(Subproblem * p, int * netorder){$/;"	f
time	header.h	/^	int time;$/;"	m	class:Chip
traceback	route.cpp	/^void traceback(int which, Point & current){$/;"	f
traceback_line	route.cpp	/^Point traceback_line(int which, int t, const Point & current, DIRECTION dir){$/;"	f
weight	header.h	/^	int weight;$/;"	m	class:GridPoint
x	header.h	/^	int x,y;$/;"	m	class:Point
y	header.h	/^	int x,y;$/;"	m	class:Point
