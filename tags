!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
ABS	header.h	10;"	d
BYTE	header.h	/^typedef unsigned char BYTE ;$/;"	t
Block	header.h	/^class Block{\/\/ a block denote by two points$/;"	c
Block::name	header.h	/^	char name[MAXSTR];$/;"	m	class:Block	access:public
Block::pt	header.h	/^	Point pt[2]; \/\/ LL=0, UR=1$/;"	m	class:Block	access:public
CORNER	header.h	/^enum CORNER{LL,UR};$/;"	g
Chip	header.h	/^class Chip{\/\/ a chip has an array, timing constraint and subproblems$/;"	c
Chip::M	header.h	/^	int N,M,T;	\/\/ array size,timing constraint$/;"	m	class:Chip	access:public
Chip::N	header.h	/^	int N,M,T;	\/\/ array size,timing constraint$/;"	m	class:Chip	access:public
Chip::T	header.h	/^	int N,M,T;	\/\/ array size,timing constraint$/;"	m	class:Chip	access:public
Chip::nSubProblem	header.h	/^	int nSubProblem;$/;"	m	class:Chip	access:public
Chip::prob	header.h	/^	Subproblem prob[MAXSUB];\/\/ note:prob starts from index 1$/;"	m	class:Chip	access:public
Chip::time	header.h	/^	int time;$/;"	m	class:Chip	access:public
DIRECTION	route.h	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	g
DOWN	route.h	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	e	enum:DIRECTION
ELECT_PENALTY	header.h	/^const int ELECT_PENALTY=20;$/;"	v
FLUID_PENALTY	header.h	/^const int FLUID_PENALTY=20;$/;"	v
GP_HEAP	main.cpp	/^typedef heap<GridPoint*,vector<GridPoint*>,GridPoint::GPpointerCmp> GP_HEAP;$/;"	t	file:
GPpointerCmp	header.h	/^	class GPpointerCmp {$/;"	c	class:GridPoint	access:public
Grid	header.h	/^typedef BYTE Grid ;$/;"	t
GridPoint	header.h	/^	GridPoint(Point pt_=Point(0,0),GridPoint *par=NULL,$/;"	f	class:GridPoint	access:public	signature:(Point pt_=Point(0,0),GridPoint *par=NULL, int t=0,int b=0,int f=0,int e=0,int s=0)
GridPoint	header.h	/^class GridPoint{$/;"	c
GridPoint::GPpointerCmp	header.h	/^	class GPpointerCmp {$/;"	c	class:GridPoint	access:public
GridPoint::GPpointerCmp::operator ()	header.h	/^		bool operator()(const GridPoint *a, const GridPoint *b) const $/;"	f	class:GridPoint::GPpointerCmp	access:public	signature:(const GridPoint *a, const GridPoint *b) const
GridPoint::GridPoint	header.h	/^	GridPoint(Point pt_=Point(0,0),GridPoint *par=NULL,$/;"	f	class:GridPoint	access:public	signature:(Point pt_=Point(0,0),GridPoint *par=NULL, int t=0,int b=0,int f=0,int e=0,int s=0)
GridPoint::bend	header.h	/^	int bend;$/;"	m	class:GridPoint	access:public
GridPoint::electro	header.h	/^	int electro;$/;"	m	class:GridPoint	access:public
GridPoint::fluidic	header.h	/^	int fluidic;$/;"	m	class:GridPoint	access:public
GridPoint::operator <	header.h	/^	bool operator < (const GridPoint& g) const{ $/;"	f	class:GridPoint	access:public	signature:(const GridPoint& g) const
GridPoint::parent	header.h	/^	GridPoint * parent;     \/\/ from which GridPoint it was propagated$/;"	m	class:GridPoint	access:public
GridPoint::pt	header.h	/^	Point pt;		\/\/ its position$/;"	m	class:GridPoint	access:public
GridPoint::stalling	header.h	/^	int stalling;$/;"	m	class:GridPoint	access:public
GridPoint::time	header.h	/^	int time;$/;"	m	class:GridPoint	access:public
GridPoint::updateWeight	header.h	/^	int updateWeight(){$/;"	f	class:GridPoint	access:public	signature:()
GridPoint::weight	header.h	/^	int weight;$/;"	m	class:GridPoint	access:public
INF	header.h	/^const Grid INF=2<<7-1;$/;"	v
LEFT	route.h	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	e	enum:DIRECTION
LL	header.h	/^enum CORNER{LL,UR};$/;"	e	enum:CORNER
M	header.h	/^	int N,M,T;	\/\/ array size,timing constraint$/;"	m	class:Chip	access:public
M	main.h	/^int N,M;				\/\/ row\/column count$/;"	v
MAX	header.h	12;"	d
MAXBLK	header.h	/^const int MAXBLK=10;$/;"	v
MAXBUF	header.h	/^const int MAXBUF=256;$/;"	v
MAXGRID	header.h	/^const int MAXGRID=30;$/;"	v
MAXNET	header.h	/^const int MAXNET=10;$/;"	v
MAXSTR	header.h	/^const int MAXSTR=30;$/;"	v
MAXSUB	header.h	/^const int MAXSUB=100;$/;"	v
MAXTIME	header.h	/^const int MAXTIME=20;$/;"	v
MHT	header.h	11;"	d
MIN	header.h	13;"	d
N	header.h	/^	int N,M,T;	\/\/ array size,timing constraint$/;"	m	class:Chip	access:public
N	main.h	/^int N,M;				\/\/ row\/column count$/;"	v
Net	header.h	/^class Net{\/\/ a net has a name and at most 3 pins$/;"	c
Net::name	header.h	/^	char name[MAXSTR];$/;"	m	class:Net	access:public
Net::numPin	header.h	/^	int numPin;$/;"	m	class:Net	access:public
Net::pin	header.h	/^	Pin pin[3];$/;"	m	class:Net	access:public
NetRouter	header.h	/^class NetRouter{$/;"	c
NetRouter::resource	header.h	/^		vector<GridPoint*> resource;      \/\/ a pointer collection $/;"	m	class:NetRouter	access:public
NetRouter::route	header.h	/^		bool route(){$/;"	f	class:NetRouter	access:public	signature:()
NetRouter::size	header.h	/^		int size() const{ return resource.size(); }$/;"	f	class:NetRouter	access:public	signature:() const
NetRouter::~NetRouter	header.h	/^		~NetRouter(){$/;"	f	class:NetRouter	access:public	signature:()
Pin	header.h	/^class Pin{\/\/ a pin has a name and a location$/;"	c
Pin::name	header.h	/^	char name[MAXSTR];$/;"	m	class:Pin	access:public
Pin::pt	header.h	/^	Point pt;$/;"	m	class:Pin	access:public
Point	header.h	/^	Point(){x=y=0;}$/;"	f	class:Point	access:public	signature:()
Point	header.h	/^	Point(int xx,int yy):x(xx),y(yy){}$/;"	f	class:Point	access:public	signature:(int xx,int yy)
Point	header.h	/^class Point{\/\/ a point denote by (row,col)$/;"	c
Point::Point	header.h	/^	Point(){x=y=0;}$/;"	f	class:Point	access:public	signature:()
Point::Point	header.h	/^	Point(int xx,int yy):x(xx),y(yy){}$/;"	f	class:Point	access:public	signature:(int xx,int yy)
Point::operator !=	header.h	/^	bool operator != (const Point & pt) const {return !operator==(pt);}$/;"	f	class:Point	access:public	signature:(const Point & pt) const
Point::operator <<	header.h	/^	friend ostream &operator <<(ostream&,Point&);$/;"	p	class:Point	access:friend	signature:(ostream&,Point&)
Point::operator ==	header.h	/^	bool operator == (const Point & pt) const {return x==pt.x && y==pt.y;}$/;"	f	class:Point	access:public	signature:(const Point & pt) const
Point::x	header.h	/^	int x,y;$/;"	m	class:Point	access:public
Point::y	header.h	/^	int x,y;$/;"	m	class:Point	access:public
PtRelativePos	route.cpp	/^DIRECTION PtRelativePos(const Point & l ,const Point & r){$/;"	f	signature:(const Point & l ,const Point & r)
PtRelativePos	route.h	/^DIRECTION PtRelativePos(const Point & l ,const Point & r);$/;"	p	signature:(const Point & l ,const Point & r)
RIGHT	route.h	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	e	enum:DIRECTION
STALL_PENALTY	header.h	/^const int STALL_PENALTY=20;$/;"	v
STAY	route.h	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	e	enum:DIRECTION
Subproblem	header.h	/^class Subproblem{\/\/ a subproblem has some blocks and nets$/;"	c
Subproblem::block	header.h	/^	Block block[MAXBLK];$/;"	m	class:Subproblem	access:public
Subproblem::nBlock	header.h	/^	int nBlock;$/;"	m	class:Subproblem	access:public
Subproblem::nNet	header.h	/^	int nNet;$/;"	m	class:Subproblem	access:public
Subproblem::net	header.h	/^	Net net[MAXNET];$/;"	m	class:Subproblem	access:public
T	header.h	/^	int N,M,T;	\/\/ array size,timing constraint$/;"	m	class:Chip	access:public
UP	route.h	/^enum DIRECTION{LEFT,RIGHT,UP,DOWN,STAY}; \/\/ LEFT, RIGHT, UP, DOWN$/;"	e	enum:DIRECTION
UR	header.h	/^enum CORNER{LL,UR};$/;"	e	enum:CORNER
__HEADER_H__	header.h	2;"	d
__HEAP_H__	heap.h	4;"	d
__MAIN_H__	main.h	2;"	d
__PARSER_H__	parser.h	2;"	d
__ROUTE_H__	route.h	2;"	d
begin	heap.h	/^	iterator begin() { return c.begin(); }$/;"	f	class:heap	access:public	signature:()
bend	header.h	/^	int bend;$/;"	m	class:GridPoint	access:public
block	header.h	/^	Block block[MAXBLK];$/;"	m	class:Subproblem	access:public
blockage	main.h	/^BYTE blockage[MAXGRID][MAXGRID];	\/\/ Blockage bitmap$/;"	v
c	heap.h	/^	Container c;$/;"	m	class:heap	access:public
checkBending	route.cpp	/^bool checkBending(const Point & p1,const Point & p2){$/;"	f	signature:(const Point & p1,const Point & p2)
checkBending	route.h	/^bool checkBending(const Point & p1,const Point & p2);$/;"	p	signature:(const Point & p1,const Point & p2)
chip	main.h	/^Chip chip;				\/\/ Chip data and subproblem$/;"	v
cmpNet	route.cpp	/^int cmpNet(const void * id1, const void * id2){$/;"	f	signature:(const void * id1, const void * id2)
comp	heap.h	/^	Compare comp;$/;"	m	class:heap	access:public
drawSubproblem	parser.cpp	/^void drawSubproblem(Subproblem * prob, int N,int M,int num,char * name){$/;"	f	signature:(Subproblem * prob, int N,int M,int num,char * name)
drawSubproblem	parser.h	/^void drawSubproblem(Subproblem *prob, int N, int M, int num, char *name);$/;"	p	signature:(Subproblem *prob, int N, int M, int num, char *name)
dx	route.cpp	/^int dx[]={-1,1,0,0,0};$/;"	v
dy	route.cpp	/^int dy[]={0,0,1,-1,0};$/;"	v
electro	header.h	/^	int electro;$/;"	m	class:GridPoint	access:public
electrodeCheck	route.cpp	/^bool electrodeCheck(const Point & pt){$/;"	f	signature:(const Point & pt)
electrodeCheck	route.h	/^bool electrodeCheck(const Point & pt);$/;"	p	signature:(const Point & pt)
empty	heap.h	/^	bool empty() const{return c.size() == 0; }$/;"	f	class:heap	access:public	signature:() const
end	heap.h	/^	iterator end() { return c.end(); }$/;"	f	class:heap	access:public	signature:()
fluidic	header.h	/^	int fluidic;$/;"	m	class:GridPoint	access:public
fluidicCheck	route.cpp	/^int fluidicCheck(int which, const Point & pt,int t){$/;"	f	signature:(int which, const Point & pt,int t)
fluidicCheck	route.h	/^int fluidicCheck(int which, const Point & pt,int t);$/;"	p	signature:(int which, const Point & pt,int t)
getBoundingBox	route.cpp	/^Block getBoundingBox(const Pin & p1, const Pin & p2){$/;"	f	signature:(const Pin & p1, const Pin & p2)
getColor	parser.cpp	/^const char * getColor(){$/;"	f	signature:()
getColor	parser.h	/^const char *getColor(void);$/;"	p	signature:(void)
getNbr	route.cpp	/^vector<Point> getNbr(const Point & pt){$/;"	f	signature:(const Point & pt)
getNbr	route.h	/^std::vector<Point> getNbr(const Point & pt);$/;"	p	signature:(const Point & pt)
grid	main.h	/^Grid grid[MAXNET][MAXGRID][MAXGRID];	\/\/ record the routes, grid[i][x][y]: the time step that net i occupies (x,y)$/;"	v
heap	heap.h	/^class heap{$/;"	c
heap::begin	heap.h	/^	iterator begin() { return c.begin(); }$/;"	f	class:heap	access:public	signature:()
heap::c	heap.h	/^	Container c;$/;"	m	class:heap	access:public
heap::comp	heap.h	/^	Compare comp;$/;"	m	class:heap	access:public
heap::empty	heap.h	/^	bool empty() const{return c.size() == 0; }$/;"	f	class:heap	access:public	signature:() const
heap::end	heap.h	/^	iterator end() { return c.end(); }$/;"	f	class:heap	access:public	signature:()
heap::iterator	heap.h	/^	typedef class Container::iterator iterator;$/;"	t	class:heap	typeref:class:heap::iterator	access:public
heap::pop	heap.h	/^	void pop() {$/;"	f	class:heap	access:public	signature:()
heap::push	heap.h	/^	void push(const T & x){$/;"	f	class:heap	access:public	signature:(const T & x)
heap::size	heap.h	/^	int size() const {return c.size();}$/;"	f	class:heap	access:public	signature:() const
heap::sort	heap.h	/^	void sort(){$/;"	f	class:heap	access:public	signature:()
heap::top	heap.h	/^	T top() const {return c.front();}$/;"	f	class:heap	access:public	signature:() const
idx	main.h	/^int idx;				\/\/ problem to solve$/;"	v
inGrid	route.cpp	/^bool inGrid(const Point & pt){$/;"	f	signature:(const Point & pt)
inGrid	route.h	/^bool inGrid(const Point & pt);$/;"	p	signature:(const Point & pt)
initBlock	route.cpp	/^void initBlock(Subproblem *p){$/;"	f	signature:(Subproblem *p)
initBlock	route.h	/^void initBlock(Subproblem *p);$/;"	p	signature:(Subproblem *p)
iterator	heap.h	/^	typedef class Container::iterator iterator;$/;"	t	class:heap	typeref:class:heap::iterator	access:public
main	main.cpp	/^int main(int argc, char * argv[]){$/;"	f	signature:(int argc, char * argv[])
main	parser_main.cpp	/^int main(int argc, char * argv[]){$/;"	f	signature:(int argc, char * argv[])
main	test.cpp	/^int main(){$/;"	f	signature:()
main	test_heap.cpp	/^int main(){$/;"	f	signature:()
nBlock	header.h	/^	int nBlock;$/;"	m	class:Subproblem	access:public
nNet	header.h	/^	int nNet;$/;"	m	class:Subproblem	access:public
nSubProblem	header.h	/^	int nSubProblem;$/;"	m	class:Chip	access:public
name	header.h	/^	char name[MAXSTR];$/;"	m	class:Block	access:public
name	header.h	/^	char name[MAXSTR];$/;"	m	class:Net	access:public
name	header.h	/^	char name[MAXSTR];$/;"	m	class:Pin	access:public
net	header.h	/^	Net net[MAXNET];$/;"	m	class:Subproblem	access:public
netcount	main.h	/^int netcount;				\/\/ current subproblem's net count$/;"	v
netorder	main.h	/^int netorder[MAXNET];			\/\/ net routing order$/;"	v
numPin	header.h	/^	int numPin;$/;"	m	class:Net	access:public
operator	header.c	/^ostream & operator <<(ostream & out,Point & pt){$/;"	f	signature:(ostream & out,Point & pt)
operator !=	header.h	/^	bool operator != (const Point & pt) const {return !operator==(pt);}$/;"	f	class:Point	access:public	signature:(const Point & pt) const
operator ()	header.h	/^		bool operator()(const GridPoint *a, const GridPoint *b) const $/;"	f	class:GridPoint::GPpointerCmp	access:public	signature:(const GridPoint *a, const GridPoint *b) const
operator <	header.h	/^	bool operator < (const GridPoint& g) const{ $/;"	f	class:GridPoint	access:public	signature:(const GridPoint& g) const
operator <<	header.h	/^	friend ostream &operator <<(ostream&,Point&);$/;"	p	class:Point	access:friend	signature:(ostream&,Point&)
operator ==	header.h	/^	bool operator == (const Point & pt) const {return x==pt.x && y==pt.y;}$/;"	f	class:Point	access:public	signature:(const Point & pt) const
parent	header.h	/^	GridPoint * parent;     \/\/ from which GridPoint it was propagated$/;"	m	class:GridPoint	access:public
parse	parser.cpp	/^Chip * parse(FILE * f,Chip * chip){$/;"	f	signature:(FILE * f,Chip * chip)
parse	parser.h	/^Chip *parse(FILE *f, Chip *chip);$/;"	p	signature:(FILE *f, Chip *chip)
path	main.h	/^Point path[MAXNET][MAXTIME];		\/\/ the routing path : path[i][t]: net i's position at time t$/;"	v
pin	header.h	/^	Pin pin[3];$/;"	m	class:Net	access:public
pop	heap.h	/^	void pop() {$/;"	f	class:heap	access:public	signature:()
prob	header.h	/^	Subproblem prob[MAXSUB];\/\/ note:prob starts from index 1$/;"	m	class:Chip	access:public
pt	header.h	/^	Point pt;		\/\/ its position$/;"	m	class:GridPoint	access:public
pt	header.h	/^	Point pt;$/;"	m	class:Pin	access:public
pt	header.h	/^	Point pt[2]; \/\/ LL=0, UR=1$/;"	m	class:Block	access:public
ptInRect	route.cpp	/^bool ptInRect(const Block & bb, const Point & pt){$/;"	f	signature:(const Block & bb, const Point & pt)
push	heap.h	/^	void push(const T & x){$/;"	f	class:heap	access:public	signature:(const T & x)
read_file	route.cpp	/^Chip * read_file(int argc, char * argv[], Chip * chip){$/;"	f	signature:(int argc, char * argv[], Chip * chip)
read_file	route.h	/^Chip * read_file(int argc, char * argv[], Chip * chip);$/;"	p	signature:(int argc, char * argv[], Chip * chip)
resource	header.h	/^		vector<GridPoint*> resource;      \/\/ a pointer collection $/;"	m	class:NetRouter	access:public
route	header.h	/^		bool route(){$/;"	f	class:NetRouter	access:public	signature:()
size	header.h	/^		int size() const{ return resource.size(); }$/;"	f	class:NetRouter	access:public	signature:() const
size	heap.h	/^	int size() const {return c.size();}$/;"	f	class:heap	access:public	signature:() const
sort	heap.h	/^	void sort(){$/;"	f	class:heap	access:public	signature:()
sortNet	route.cpp	/^void sortNet(Subproblem * p, int * netorder){$/;"	f	signature:(Subproblem * p, int * netorder)
sortNet	route.h	/^void sortNet(Subproblem * p, int * netorder);$/;"	p	signature:(Subproblem * p, int * netorder)
stalling	header.h	/^	int stalling;$/;"	m	class:GridPoint	access:public
string_heap	test_heap.cpp	/^typedef heap<string*,vector<string*> > string_heap;$/;"	t	file:
swap	route.cpp	/^void swap(int &a,int &b){$/;"	f	signature:(int &a,int &b)
time	header.h	/^	int time;$/;"	m	class:Chip	access:public
time	header.h	/^	int time;$/;"	m	class:GridPoint	access:public
top	heap.h	/^	T top() const {return c.front();}$/;"	f	class:heap	access:public	signature:() const
traceback	route.cpp	/^void traceback(int which, Point & current){$/;"	f	signature:(int which, Point & current)
traceback	route.h	/^void traceback(int which, Point & current);$/;"	p	signature:(int which, Point & current)
traceback_line	route.cpp	/^Point traceback_line(int which, int t, const Point & current, DIRECTION dir){$/;"	f	signature:(int which, int t, const Point & current, DIRECTION dir)
traceback_line	route.h	/^Point traceback_line(int which, int t, const Point & current, DIRECTION dir);$/;"	p	signature:(int which, int t, const Point & current, DIRECTION dir)
updateWeight	header.h	/^	int updateWeight(){$/;"	f	class:GridPoint	access:public	signature:()
weight	header.h	/^	int weight;$/;"	m	class:GridPoint	access:public
x	header.h	/^	int x,y;$/;"	m	class:Point	access:public
y	header.h	/^	int x,y;$/;"	m	class:Point	access:public
~NetRouter	header.h	/^		~NetRouter(){$/;"	f	class:NetRouter	access:public	signature:()
